// Generated by CIRCT firtool-1.138.0
module VGAController(
  input        clock,
               reset,
  output       io_hSync,
               io_vSync,
  output [9:0] io_pixelPosX,
               io_pixelPosY,
  output       io_pixelPosIsValid
);

  reg  [9:0] horizontalCounterQ;
  reg  [9:0] verticalCounterQ;
  reg  [9:0] pixelPosXQ;
  reg  [9:0] pixelPosYQ;
  wire       _GEN = pixelPosXQ < 10'h27F;
  wire       _GEN_0 = horizontalCounterQ == 10'h31F;
  wire       _GEN_1 = _GEN | ~_GEN_0;
  wire       _GEN_2 = verticalCounterQ == 10'h20C;
  always @(posedge clock) begin
    if (reset) begin
      horizontalCounterQ <= 10'h0;
      verticalCounterQ <= 10'h0;
      pixelPosXQ <= 10'h0;
      pixelPosYQ <= 10'h0;
    end
    else begin
      horizontalCounterQ <= _GEN_1 ? horizontalCounterQ + 10'h1 : 10'h0;
      if (_GEN_1) begin
      end
      else
        verticalCounterQ <= _GEN_2 ? 10'h0 : verticalCounterQ + 10'h1;
      if (_GEN)
        pixelPosXQ <= pixelPosXQ + 10'h1;
      else if (_GEN_0)
        pixelPosXQ <= 10'h0;
      if (_GEN_1) begin
      end
      else if (_GEN_2)
        pixelPosYQ <= 10'h0;
      else if (pixelPosYQ < 10'h1DF)
        pixelPosYQ <= pixelPosYQ + 10'h1;
    end
  end // always @(posedge)
  assign io_hSync = ~(horizontalCounterQ > 10'h28F & horizontalCounterQ < 10'h2F0);
  assign io_vSync = ~(verticalCounterQ > 10'h1E9 & verticalCounterQ < 10'h1EC);
  assign io_pixelPosX = pixelPosXQ;
  assign io_pixelPosY = pixelPosYQ;
  assign io_pixelPosIsValid = horizontalCounterQ < 10'h280 & verticalCounterQ < 10'h1E0;
endmodule

module TetrisScoreDisplay(
  input        io_reset,
               io_pixelPosIsValid,
  input  [9:0] io_pxX,
               io_pxY,
  input  [3:0] io_score_0,
               io_score_1,
               io_score_2,
               io_score_3,
  output [1:0] io_vgaR,
               io_vgaG
);

  wire [6:0] _scoreXCoord_T = io_pxX[6:0] - 7'h14;
  wire [4:0] _fontBitmapYIndex_T_1 = io_pxY[4:0] - {2'h0, io_pxY[4:2]};
  wire       drawScore =
    io_pxX > 10'h113 & io_pxX < 10'h194 & (|(io_pxY[9:5])) & io_pxY < 10'h40
    & _scoreXCoord_T[4:3] != 2'h3 & _fontBitmapYIndex_T_1[4:2] < 3'h5;
  reg  [3:0] casez_tmp;
  always_comb begin
    casez (2'h3 - _scoreXCoord_T[6:5])
      2'b00:
        casez_tmp = io_score_0;
      2'b01:
        casez_tmp = io_score_1;
      2'b10:
        casez_tmp = io_score_2;
      default:
        casez_tmp = io_score_3;
    endcase
  end // always_comb
  wire [3:0] scoreDigit = drawScore ? casez_tmp : 4'h0;
  wire       _GEN = io_pixelPosIsValid & ~io_reset;
  reg  [2:0] casez_tmp_0;
  always_comb begin
    casez (scoreDigit)
      4'b0000:
        casez_tmp_0 = 3'h7;
      4'b0001:
        casez_tmp_0 = 3'h6;
      4'b0010:
        casez_tmp_0 = 3'h7;
      4'b0011:
        casez_tmp_0 = 3'h7;
      4'b0100:
        casez_tmp_0 = 3'h5;
      4'b0101:
        casez_tmp_0 = 3'h7;
      4'b0110:
        casez_tmp_0 = 3'h7;
      4'b0111:
        casez_tmp_0 = 3'h7;
      4'b1000:
        casez_tmp_0 = 3'h7;
      4'b1001:
        casez_tmp_0 = 3'h7;
      4'b1010:
        casez_tmp_0 = 3'h7;
      4'b1011:
        casez_tmp_0 = 3'h7;
      4'b1100:
        casez_tmp_0 = 3'h7;
      4'b1101:
        casez_tmp_0 = 3'h7;
      4'b1110:
        casez_tmp_0 = 3'h7;
      default:
        casez_tmp_0 = 3'h7;
    endcase
  end // always_comb
  reg  [2:0] casez_tmp_1;
  always_comb begin
    casez (scoreDigit)
      4'b0000:
        casez_tmp_1 = 3'h5;
      4'b0001:
        casez_tmp_1 = 3'h2;
      4'b0010:
        casez_tmp_1 = 3'h1;
      4'b0011:
        casez_tmp_1 = 3'h1;
      4'b0100:
        casez_tmp_1 = 3'h5;
      4'b0101:
        casez_tmp_1 = 3'h4;
      4'b0110:
        casez_tmp_1 = 3'h4;
      4'b0111:
        casez_tmp_1 = 3'h1;
      4'b1000:
        casez_tmp_1 = 3'h5;
      4'b1001:
        casez_tmp_1 = 3'h5;
      4'b1010:
        casez_tmp_1 = 3'h5;
      4'b1011:
        casez_tmp_1 = 3'h5;
      4'b1100:
        casez_tmp_1 = 3'h5;
      4'b1101:
        casez_tmp_1 = 3'h5;
      4'b1110:
        casez_tmp_1 = 3'h5;
      default:
        casez_tmp_1 = 3'h5;
    endcase
  end // always_comb
  reg  [2:0] casez_tmp_2;
  always_comb begin
    casez (scoreDigit)
      4'b0000:
        casez_tmp_2 = 3'h5;
      4'b0001:
        casez_tmp_2 = 3'h2;
      4'b0010:
        casez_tmp_2 = 3'h7;
      4'b0011:
        casez_tmp_2 = 3'h7;
      4'b0100:
        casez_tmp_2 = 3'h7;
      4'b0101:
        casez_tmp_2 = 3'h7;
      4'b0110:
        casez_tmp_2 = 3'h7;
      4'b0111:
        casez_tmp_2 = 3'h1;
      4'b1000:
        casez_tmp_2 = 3'h7;
      4'b1001:
        casez_tmp_2 = 3'h7;
      4'b1010:
        casez_tmp_2 = 3'h5;
      4'b1011:
        casez_tmp_2 = 3'h5;
      4'b1100:
        casez_tmp_2 = 3'h5;
      4'b1101:
        casez_tmp_2 = 3'h5;
      4'b1110:
        casez_tmp_2 = 3'h5;
      default:
        casez_tmp_2 = 3'h5;
    endcase
  end // always_comb
  reg  [2:0] casez_tmp_3;
  always_comb begin
    casez (scoreDigit)
      4'b0000:
        casez_tmp_3 = 3'h5;
      4'b0001:
        casez_tmp_3 = 3'h2;
      4'b0010:
        casez_tmp_3 = 3'h4;
      4'b0011:
        casez_tmp_3 = 3'h1;
      4'b0100:
        casez_tmp_3 = 3'h1;
      4'b0101:
        casez_tmp_3 = 3'h1;
      4'b0110:
        casez_tmp_3 = 3'h5;
      4'b0111:
        casez_tmp_3 = 3'h1;
      4'b1000:
        casez_tmp_3 = 3'h5;
      4'b1001:
        casez_tmp_3 = 3'h1;
      4'b1010:
        casez_tmp_3 = 3'h5;
      4'b1011:
        casez_tmp_3 = 3'h5;
      4'b1100:
        casez_tmp_3 = 3'h5;
      4'b1101:
        casez_tmp_3 = 3'h5;
      4'b1110:
        casez_tmp_3 = 3'h5;
      default:
        casez_tmp_3 = 3'h5;
    endcase
  end // always_comb
  reg  [2:0] casez_tmp_4;
  always_comb begin
    casez (scoreDigit)
      4'b0000:
        casez_tmp_4 = 3'h7;
      4'b0001:
        casez_tmp_4 = 3'h7;
      4'b0010:
        casez_tmp_4 = 3'h7;
      4'b0011:
        casez_tmp_4 = 3'h7;
      4'b0100:
        casez_tmp_4 = 3'h1;
      4'b0101:
        casez_tmp_4 = 3'h7;
      4'b0110:
        casez_tmp_4 = 3'h7;
      4'b0111:
        casez_tmp_4 = 3'h1;
      4'b1000:
        casez_tmp_4 = 3'h7;
      4'b1001:
        casez_tmp_4 = 3'h7;
      4'b1010:
        casez_tmp_4 = 3'h7;
      4'b1011:
        casez_tmp_4 = 3'h7;
      4'b1100:
        casez_tmp_4 = 3'h7;
      4'b1101:
        casez_tmp_4 = 3'h7;
      4'b1110:
        casez_tmp_4 = 3'h7;
      default:
        casez_tmp_4 = 3'h7;
    endcase
  end // always_comb
  reg  [2:0] casez_tmp_5;
  always_comb begin
    casez (_fontBitmapYIndex_T_1[4:2])
      3'b000:
        casez_tmp_5 = casez_tmp_0;
      3'b001:
        casez_tmp_5 = casez_tmp_1;
      3'b010:
        casez_tmp_5 = casez_tmp_2;
      3'b011:
        casez_tmp_5 = casez_tmp_3;
      3'b100:
        casez_tmp_5 = casez_tmp_4;
      3'b101:
        casez_tmp_5 = casez_tmp_0;
      3'b110:
        casez_tmp_5 = casez_tmp_0;
      default:
        casez_tmp_5 = casez_tmp_0;
    endcase
  end // always_comb
  wire [2:0] _GEN_0 =
    (_GEN & drawScore ? casez_tmp_5 : 3'h0) >> 2'h2 - _scoreXCoord_T[4:3];
  wire [1:0] io_vgaG_0 = {2{_GEN & drawScore & _GEN_0[0]}};
  assign io_vgaR = io_vgaG_0;
  assign io_vgaG = io_vgaG_0;
endmodule

module TetrisGameOverDisplay(
  input        io_reset,
               io_pixelPosIsValid,
  input  [9:0] io_pxX,
               io_pxY,
  output [1:0] io_vgaR,
  output       io_pixelDataValid
);

  wire [6:0]  _textCoordStartX_T = io_pxX[6:0] - 7'h24;
  wire [5:0]  _textCoordStartY_T = io_pxY[5:0] - 6'hC;
  wire        _GEN = io_pixelPosIsValid & ~io_reset;
  wire        _GEN_0 =
    io_pxX > 10'h123 & io_pxX < 10'h181 & io_pxY > 10'hCB & io_pxY < 10'hF9
    & _textCoordStartX_T[6:2] < 5'h17 & _textCoordStartY_T[5:2] < 4'hB;
  reg  [22:0] casez_tmp;
  always_comb begin
    casez (_textCoordStartY_T[5:2])
      4'b0000:
        casez_tmp = 23'h7D17DF;
      4'b0001:
        casez_tmp = 23'h5B441;
      4'b0010:
        casez_tmp = 23'h3D57D9;
      4'b0011:
        casez_tmp = 23'h51451;
      4'b0100:
        casez_tmp = 23'h7D145F;
      4'b0101:
        casez_tmp = 23'h0;
      4'b0110:
        casez_tmp = 23'h7DF45F;
      4'b0111:
        casez_tmp = 23'h441451;
      4'b1000:
        casez_tmp = 23'h7CF291;
      4'b1001:
        casez_tmp = 23'h241291;
      4'b1010:
        casez_tmp = 23'h45F11F;
      4'b1011:
        casez_tmp = 23'h7D17DF;
      4'b1100:
        casez_tmp = 23'h7D17DF;
      4'b1101:
        casez_tmp = 23'h7D17DF;
      4'b1110:
        casez_tmp = 23'h7D17DF;
      default:
        casez_tmp = 23'h7D17DF;
    endcase
  end // always_comb
  wire [22:0] _GEN_1 = casez_tmp >> _textCoordStartX_T[6:2];
  assign io_vgaR = {2{_GEN & _GEN_0 & _GEN_1[0]}};
  assign io_pixelDataValid = _GEN & _GEN_0 & _GEN_1[0];
endmodule

module TetrisDisplay(
  input         io_reset,
                io_pixelPosIsValid,
  input  [9:0]  io_pxX,
                io_pxY,
  input         io_showGameOver,
  input  [3:0]  io_score_0,
                io_score_1,
                io_score_2,
                io_score_3,
  input  [19:0] io_boardRowData,
  output        io_coordsValid,
  output [4:0]  io_boardYCoord,
  output [1:0]  io_vgaR,
                io_vgaG,
                io_vgaB
);

  wire [1:0] _GEN;
  wire [1:0] _GEN_0;
  wire [1:0] displayVgaR;
  wire       _GEN_1;
  wire       _GEN_2;
  wire [1:0] _gameOverDisplay_io_vgaR;
  wire       _gameOverDisplay_io_pixelDataValid;
  wire [1:0] _scoreDisplay_io_vgaR;
  wire [1:0] _scoreDisplay_io_vgaG;
  wire       xWithinTheBoard = (|(io_pxX[9:8])) & io_pxX < 10'h1A0;
  wire       yWithinTheBoard = (|(io_pxY[9:6])) & io_pxY < 10'h180;
  wire       drawBlockFrame = (&(io_pxY[3:0])) | io_pxY[3:0] == 4'h0 | (&(io_pxX[3:0]));
  wire       drawBoard = xWithinTheBoard & yWithinTheBoard & ~drawBlockFrame;
  wire       _colorBits_candidates_T_40 = io_pxX[7:4] == 4'h0;
  wire       _colorBits_candidates_T_44 = io_pxX[7:4] == 4'h1;
  wire       _colorBits_candidates_T_48 = io_pxX[7:4] == 4'h2;
  wire       _colorBits_candidates_T_52 = io_pxX[7:4] == 4'h3;
  wire       _colorBits_candidates_T_56 = io_pxX[7:4] == 4'h4;
  wire       _colorBits_candidates_T_60 = io_pxX[7:4] == 4'h5;
  wire       _colorBits_candidates_T_64 = io_pxX[7:4] == 4'h6;
  wire       _colorBits_candidates_T_68 = io_pxX[7:4] == 4'h7;
  wire       _colorBits_candidates_T_72 = io_pxX[7:4] == 4'h8;
  wire       _colorBits_candidates_T_76 = io_pxX[7:4] == 4'h9;
  wire [1:0] color =
    {_colorBits_candidates_T_40 & io_boardRowData[1] | _colorBits_candidates_T_44
       & io_boardRowData[3] | _colorBits_candidates_T_48 & io_boardRowData[5]
       | _colorBits_candidates_T_52 & io_boardRowData[7] | _colorBits_candidates_T_56
       & io_boardRowData[9] | _colorBits_candidates_T_60 & io_boardRowData[11]
       | _colorBits_candidates_T_64 & io_boardRowData[13] | _colorBits_candidates_T_68
       & io_boardRowData[15] | _colorBits_candidates_T_72 & io_boardRowData[17]
       | _colorBits_candidates_T_76 & io_boardRowData[19],
     _colorBits_candidates_T_40 & io_boardRowData[0] | _colorBits_candidates_T_44
       & io_boardRowData[2] | _colorBits_candidates_T_48 & io_boardRowData[4]
       | _colorBits_candidates_T_52 & io_boardRowData[6] | _colorBits_candidates_T_56
       & io_boardRowData[8] | _colorBits_candidates_T_60 & io_boardRowData[10]
       | _colorBits_candidates_T_64 & io_boardRowData[12] | _colorBits_candidates_T_68
       & io_boardRowData[14] | _colorBits_candidates_T_72 & io_boardRowData[16]
       | _colorBits_candidates_T_76 & io_boardRowData[18]};
  wire       drawOutlines =
    io_pxY == 10'h0 | io_pxX == 10'h0 | io_pxY == 10'h1DF | io_pxX == 10'h27F
    | (io_pxY == 10'h40 | io_pxY == 10'h180) & (|(io_pxX[9:8])) & io_pxX < 10'h1A1
    | (io_pxX == 10'h100 | io_pxX == 10'h1A0) & (|(io_pxY[9:6])) & io_pxY < 10'h181;
  wire       displayBoard =
    drawBoard | drawBlockFrame & xWithinTheBoard & yWithinTheBoard | drawOutlines;
  assign _GEN_2 = io_pixelPosIsValid & ~io_reset;
  assign _GEN_1 = color == 2'h1;
  wire       _GEN_3 = color == 2'h2;
  assign displayVgaR =
    _GEN_2
      ? (drawOutlines
           ? 2'h3
           : drawBoard ? (_GEN_1 ? 2'h3 : _GEN_3 ? 2'h0 : {1'h0, &color}) : 2'h0)
      : 2'h0;
  assign _GEN_0 = _GEN_1 ? 2'h1 : {2{_GEN_3}};
  assign _GEN = _GEN_3 ? 2'h1 : {2{&color}};
  TetrisScoreDisplay scoreDisplay (
    .io_reset           (io_reset),
    .io_pixelPosIsValid (io_pixelPosIsValid & ~drawBoard),
    .io_pxX             (io_pxX),
    .io_pxY             (io_pxY),
    .io_score_0         (io_score_0),
    .io_score_1         (io_score_1),
    .io_score_2         (io_score_2),
    .io_score_3         (io_score_3),
    .io_vgaR            (_scoreDisplay_io_vgaR),
    .io_vgaG            (_scoreDisplay_io_vgaG)
  );
  TetrisGameOverDisplay gameOverDisplay (
    .io_reset           (io_reset),
    .io_pixelPosIsValid (io_pixelPosIsValid & io_showGameOver),
    .io_pxX             (io_pxX),
    .io_pxY             (io_pxY),
    .io_vgaR            (_gameOverDisplay_io_vgaR),
    .io_pixelDataValid  (_gameOverDisplay_io_pixelDataValid)
  );
  assign io_coordsValid = drawBoard;
  assign io_boardYCoord = io_pxY[8:4] - 5'h4;
  assign io_vgaR =
    displayBoard
      ? (_gameOverDisplay_io_pixelDataValid ? _gameOverDisplay_io_vgaR : displayVgaR)
      : _scoreDisplay_io_vgaR;
  assign io_vgaG =
    displayBoard
      ? (_gameOverDisplay_io_pixelDataValid | ~_GEN_2 | drawOutlines | ~drawBoard
           ? 2'h0
           : _GEN_0)
      : _scoreDisplay_io_vgaG;
  assign io_vgaB =
    ~displayBoard | _gameOverDisplay_io_pixelDataValid | ~_GEN_2 | drawOutlines
    | ~drawBoard | _GEN_1
      ? 2'h0
      : _GEN;
endmodule

module TetrisBoardMemory(
  input         clock,
                io_wen,
                io_ren,
  input  [4:0]  io_readYCoord,
                io_writeYCoord,
  input  [19:0] io_writeRowData,
  output [19:0] io_readRowData
);

  reg [19:0] board_0;
  reg [19:0] board_1;
  reg [19:0] board_2;
  reg [19:0] board_3;
  reg [19:0] board_4;
  reg [19:0] board_5;
  reg [19:0] board_6;
  reg [19:0] board_7;
  reg [19:0] board_8;
  reg [19:0] board_9;
  reg [19:0] board_10;
  reg [19:0] board_11;
  reg [19:0] board_12;
  reg [19:0] board_13;
  reg [19:0] board_14;
  reg [19:0] board_15;
  reg [19:0] board_16;
  reg [19:0] board_17;
  reg [19:0] board_18;
  reg [19:0] board_19;
  reg [19:0] casez_tmp;
  always_comb begin
    casez (io_readYCoord)
      5'b00000:
        casez_tmp = board_0;
      5'b00001:
        casez_tmp = board_1;
      5'b00010:
        casez_tmp = board_2;
      5'b00011:
        casez_tmp = board_3;
      5'b00100:
        casez_tmp = board_4;
      5'b00101:
        casez_tmp = board_5;
      5'b00110:
        casez_tmp = board_6;
      5'b00111:
        casez_tmp = board_7;
      5'b01000:
        casez_tmp = board_8;
      5'b01001:
        casez_tmp = board_9;
      5'b01010:
        casez_tmp = board_10;
      5'b01011:
        casez_tmp = board_11;
      5'b01100:
        casez_tmp = board_12;
      5'b01101:
        casez_tmp = board_13;
      5'b01110:
        casez_tmp = board_14;
      5'b01111:
        casez_tmp = board_15;
      5'b10000:
        casez_tmp = board_16;
      5'b10001:
        casez_tmp = board_17;
      5'b10010:
        casez_tmp = board_18;
      5'b10011:
        casez_tmp = board_19;
      5'b10100:
        casez_tmp = board_0;
      5'b10101:
        casez_tmp = board_0;
      5'b10110:
        casez_tmp = board_0;
      5'b10111:
        casez_tmp = board_0;
      5'b11000:
        casez_tmp = board_0;
      5'b11001:
        casez_tmp = board_0;
      5'b11010:
        casez_tmp = board_0;
      5'b11011:
        casez_tmp = board_0;
      5'b11100:
        casez_tmp = board_0;
      5'b11101:
        casez_tmp = board_0;
      5'b11110:
        casez_tmp = board_0;
      default:
        casez_tmp = board_0;
    endcase
  end // always_comb
  always @(posedge clock) begin
    if (io_wen & io_writeYCoord == 5'h0)
      board_0 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h1)
      board_1 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h2)
      board_2 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h3)
      board_3 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h4)
      board_4 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h5)
      board_5 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h6)
      board_6 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h7)
      board_7 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h8)
      board_8 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h9)
      board_9 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'hA)
      board_10 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'hB)
      board_11 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'hC)
      board_12 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'hD)
      board_13 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'hE)
      board_14 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'hF)
      board_15 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h10)
      board_16 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h11)
      board_17 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h12)
      board_18 <= io_writeRowData;
    if (io_wen & io_writeYCoord == 5'h13)
      board_19 <= io_writeRowData;
  end // always @(posedge)
  assign io_readRowData = io_ren ? casez_tmp : 20'h0;
endmodule

module MillisecondTimer(
  input  clock,
         reset,
  output io_tick
);

  reg [14:0] msTimerQ;
  always @(posedge clock) begin
    if (reset)
      msTimerQ <= 15'h0;
    else
      msTimerQ <= msTimerQ < 15'h61A8 ? msTimerQ + 15'h1 : 15'h0;
  end // always @(posedge)
  assign io_tick = msTimerQ == 15'h61A8;
endmodule

module TetrisInputs(
  input  clock,
         reset,
         io_millisecondTimerTick,
         io_clear,
         io_rotateButtonPressed,
         io_leftButtonPressed,
         io_rightButtonPressed,
         io_downButtonPressed,
  output io_rotateButtonActive,
         io_leftButtonActive,
         io_rightButtonActive,
         io_downButtonActive
);

  reg  [7:0] buttonTimerQ_0;
  reg  [7:0] buttonTimerQ_1;
  reg  [7:0] buttonTimerQ_2;
  reg  [7:0] buttonTimerQ_3;
  reg        buttonActiveQ_0;
  reg        buttonActiveQ_1;
  reg        buttonActiveQ_2;
  reg        buttonActiveQ_3;
  wire       _GEN = ~io_rotateButtonPressed | buttonActiveQ_0 & io_clear;
  wire       _GEN_0 = io_millisecondTimerTick & ~buttonActiveQ_0;
  wire [7:0] _buttonTimerD_T = buttonTimerQ_0 + 8'h1;
  wire       _GEN_1 = ~io_leftButtonPressed | buttonActiveQ_1 & io_clear;
  wire       _GEN_2 = io_millisecondTimerTick & ~buttonActiveQ_1;
  wire [7:0] _buttonTimerD_T_2 = buttonTimerQ_1 + 8'h1;
  wire       _GEN_3 = ~io_rightButtonPressed | buttonActiveQ_2 & io_clear;
  wire       _GEN_4 = io_millisecondTimerTick & ~buttonActiveQ_2;
  wire [7:0] _buttonTimerD_T_4 = buttonTimerQ_2 + 8'h1;
  wire       _GEN_5 = ~io_downButtonPressed | buttonActiveQ_3 & io_clear;
  wire       _GEN_6 = io_millisecondTimerTick & ~buttonActiveQ_3;
  wire [7:0] _buttonTimerD_T_6 = buttonTimerQ_3 + 8'h1;
  always @(posedge clock) begin
    if (reset) begin
      buttonTimerQ_0 <= 8'h0;
      buttonTimerQ_1 <= 8'h0;
      buttonTimerQ_2 <= 8'h0;
      buttonTimerQ_3 <= 8'h0;
      buttonActiveQ_0 <= 1'h0;
      buttonActiveQ_1 <= 1'h0;
      buttonActiveQ_2 <= 1'h0;
      buttonActiveQ_3 <= 1'h0;
    end
    else begin
      if (_GEN)
        buttonTimerQ_0 <= 8'h0;
      else if (_GEN_0)
        buttonTimerQ_0 <= _buttonTimerD_T;
      if (_GEN_1)
        buttonTimerQ_1 <= 8'h0;
      else if (_GEN_2)
        buttonTimerQ_1 <= _buttonTimerD_T_2;
      if (_GEN_3)
        buttonTimerQ_2 <= 8'h0;
      else if (_GEN_4)
        buttonTimerQ_2 <= _buttonTimerD_T_4;
      if (_GEN_5)
        buttonTimerQ_3 <= 8'h0;
      else if (_GEN_6)
        buttonTimerQ_3 <= _buttonTimerD_T_6;
      if (buttonActiveQ_0)
        buttonActiveQ_0 <= ~io_clear;
      else
        buttonActiveQ_0 <=
          io_rotateButtonPressed
          & (_GEN ? 8'h0 : _GEN_0 ? _buttonTimerD_T : buttonTimerQ_0) > 8'h63;
      if (buttonActiveQ_1)
        buttonActiveQ_1 <= ~io_clear;
      else
        buttonActiveQ_1 <=
          io_leftButtonPressed
          & (_GEN_1 ? 8'h0 : _GEN_2 ? _buttonTimerD_T_2 : buttonTimerQ_1) > 8'h63;
      if (buttonActiveQ_2)
        buttonActiveQ_2 <= ~io_clear;
      else
        buttonActiveQ_2 <=
          io_rightButtonPressed
          & (_GEN_3 ? 8'h0 : _GEN_4 ? _buttonTimerD_T_4 : buttonTimerQ_2) > 8'h63;
      if (buttonActiveQ_3)
        buttonActiveQ_3 <= ~io_clear;
      else
        buttonActiveQ_3 <=
          io_downButtonPressed
          & (|(_GEN_5 ? 8'h0 : _GEN_6 ? _buttonTimerD_T_6 : buttonTimerQ_3));
    end
  end // always @(posedge)
  assign io_rotateButtonActive = buttonActiveQ_0;
  assign io_leftButtonActive = buttonActiveQ_1;
  assign io_rightButtonActive = buttonActiveQ_2;
  assign io_downButtonActive = buttonActiveQ_3;
endmodule

module TetrisLFSRPseudoRandomNumGen(
  input        clock,
               reset,
               io_enable,
  output [2:0] io_random
);

  reg [15:0] lfsrQ;
  always @(posedge clock) begin
    if (reset)
      lfsrQ <= 16'hACE1;
    else if (io_enable)
      lfsrQ <= {lfsrQ[14:0], lfsrQ[15] ^ lfsrQ[13] ^ lfsrQ[12] ^ lfsrQ[10]};
  end // always @(posedge)
  assign io_random = (&(lfsrQ[2:0])) ? 3'h6 : lfsrQ[2:0];
endmodule

module AdderSubtracter(
  input  [4:0] io_a,
  input        io_subtract,
  output [4:0] io_result
);

  wire [5:0] adderRes = {io_a, 1'h1} + (io_subtract ? 6'h3D : 6'h2);
  assign io_result = adderRes[5:1];
endmodule

module TetrisShapeDataProvider(
  input  [2:0] io_shapeSelector,
  input  [1:0] io_shapeRotationSelector,
               io_shapeDataRowIndex,
  output [3:0] io_shapeRowData,
  output [1:0] io_currentShapeLastRotationId
);

  wire       _GEN = io_shapeRotationSelector == 2'h0;
  wire       _GEN_0 = io_shapeRotationSelector == 2'h1;
  wire [7:0] _GEN_1 = _GEN ? 8'h70 : 8'h0;
  reg  [7:0] casez_tmp;
  always_comb begin
    casez (io_shapeRotationSelector)
      2'b00:
        casez_tmp = _GEN_1;
      2'b01:
        casez_tmp = 8'h32;
      2'b10:
        casez_tmp = 8'h72;
      default:
        casez_tmp = 8'h31;
    endcase
  end // always_comb
  reg  [7:0] casez_tmp_0;
  always_comb begin
    casez (io_shapeRotationSelector)
      2'b00:
        casez_tmp_0 = _GEN_1;
      2'b01:
        casez_tmp_0 = 8'h23;
      2'b10:
        casez_tmp_0 = 8'h74;
      default:
        casez_tmp_0 = 8'h11;
    endcase
  end // always_comb
  reg  [7:0] casez_tmp_1;
  always_comb begin
    casez (io_shapeRotationSelector)
      2'b00:
        casez_tmp_1 = {7'h0, _GEN};
      2'b01:
        casez_tmp_1 = 8'h2;
      2'b10:
        casez_tmp_1 = 8'h0;
      default:
        casez_tmp_1 = 8'h3;
    endcase
  end // always_comb
  reg  [7:0] casez_tmp_2;
  always_comb begin
    casez (io_shapeRotationSelector)
      2'b00:
        casez_tmp_2 = 8'h71;
      2'b01:
        casez_tmp_2 = 8'h13;
      2'b10:
        casez_tmp_2 = 8'h70;
      default:
        casez_tmp_2 = 8'h22;
    endcase
  end // always_comb
  reg  [7:0] casez_tmp_3;
  wire [7:0] _GEN_2 = io_shapeSelector == 3'h6 & _GEN ? 8'h33 : 8'h0;
  always_comb begin
    casez (io_shapeSelector)
      3'b000:
        casez_tmp_3 = _GEN_0 ? 8'h11 : _GEN ? 8'hF0 : 8'h0;
      3'b001:
        casez_tmp_3 = casez_tmp;
      3'b010:
        casez_tmp_3 = casez_tmp_0;
      3'b011:
        casez_tmp_3 = casez_tmp_2;
      3'b100:
        casez_tmp_3 = _GEN_0 ? 8'h32 : _GEN ? 8'h30 : 8'h0;
      3'b101:
        casez_tmp_3 = _GEN_0 ? 8'h31 : _GEN ? 8'h60 : 8'h0;
      3'b110:
        casez_tmp_3 = _GEN_2;
      default:
        casez_tmp_3 = _GEN_2;
    endcase
  end // always_comb
  reg  [7:0] casez_tmp_4;
  wire       _GEN_3 = io_shapeRotationSelector == 2'h2;
  always_comb begin
    casez (io_shapeSelector)
      3'b000:
        casez_tmp_4 = _GEN_0 ? 8'h11 : 8'h0;
      3'b001:
        casez_tmp_4 =
          (&io_shapeRotationSelector)
            ? 8'h1
            : _GEN_3 ? 8'h0 : {6'h0, _GEN_0 | _GEN, 1'h0};
      3'b010:
        casez_tmp_4 = casez_tmp_1;
      3'b011:
        casez_tmp_4 = (&io_shapeRotationSelector) ? 8'h3 : _GEN_3 ? 8'h4 : {7'h0, _GEN_0};
      3'b100:
        casez_tmp_4 = _GEN_0 ? 8'h1 : _GEN ? 8'h6 : 8'h0;
      3'b101:
        casez_tmp_4 = _GEN_0 ? 8'h2 : _GEN ? 8'h3 : 8'h0;
      3'b110:
        casez_tmp_4 = 8'h0;
      default:
        casez_tmp_4 = 8'h0;
    endcase
  end // always_comb
  reg  [3:0] casez_tmp_5;
  always_comb begin
    casez (io_shapeDataRowIndex)
      2'b00:
        casez_tmp_5 = casez_tmp_3[3:0];
      2'b01:
        casez_tmp_5 = casez_tmp_3[7:4];
      2'b10:
        casez_tmp_5 = casez_tmp_4[3:0];
      default:
        casez_tmp_5 = casez_tmp_4[7:4];
    endcase
  end // always_comb
  assign io_shapeRowData = casez_tmp_5;
  assign io_currentShapeLastRotationId =
    io_shapeSelector == 3'h0
      ? 2'h1
      : io_shapeSelector == 3'h1 | io_shapeSelector == 3'h2 | io_shapeSelector == 3'h3
          ? 2'h3
          : {1'h0, io_shapeSelector == 3'h4 | io_shapeSelector == 3'h5};
endmodule

module TetrisAddCurrentShapeToOrRemoveFromTheBoard(
  input         clock,
                reset,
                io_start,
                io_clearShape,
  input  [3:0]  io_shapeRowData,
  input  [1:0]  io_shapeColor,
  input  [19:0] io_boardRowDataIn,
  input  [3:0]  io_shapeXCoord,
  output        io_reading,
                io_writing,
  output [19:0] io_boardRowDataOut,
  output [1:0]  io_rowIndex,
  output        io_done
);

  reg  [1:0]  stateQ;
  reg  [19:0] boardRowDataQ;
  reg  [1:0]  rowIndexQ;
  reg         doneQ;
  reg         clearingQ;
  wire        inReadingState = stateQ == 2'h1;
  wire        inWritingState = stateQ == 2'h2;
  wire [4:0]  shapeXCoord =
    {1'h0, io_shapeXCoord} + 5'h1 > 5'hA ? 5'hA : {io_shapeXCoord, 1'h0};
  wire [4:0]  _boardBlockIndex_1_T = shapeXCoord + 5'h2;
  wire [4:0]  _boardBlockIndex_2_T = shapeXCoord + 5'h4;
  wire [4:0]  _boardBlockIndex_3_T = shapeXCoord + 5'h6;
  wire [1:0]  newBits = clearingQ ? 2'h0 : io_shapeColor;
  wire        _resultBits_T_20 = shapeXCoord[4:1] == 4'h0;
  wire        _resultBits_T_28 = _boardBlockIndex_1_T == 5'h0;
  wire        _resultBits_T_36 = _boardBlockIndex_2_T == 5'h0;
  wire        _resultBits_T_44 = _boardBlockIndex_3_T == 5'h0;
  wire        _resultBits_T_60 = _boardBlockIndex_1_T == 5'h1;
  wire        _resultBits_T_68 = _boardBlockIndex_2_T == 5'h1;
  wire        _resultBits_T_76 = _boardBlockIndex_3_T == 5'h1;
  wire        _resultBits_T_84 = shapeXCoord[4:1] == 4'h1;
  wire        _resultBits_T_92 = _boardBlockIndex_1_T == 5'h2;
  wire        _resultBits_T_100 = _boardBlockIndex_2_T == 5'h2;
  wire        _resultBits_T_108 = _boardBlockIndex_3_T == 5'h2;
  wire        _resultBits_T_124 = _boardBlockIndex_1_T == 5'h3;
  wire        _resultBits_T_132 = _boardBlockIndex_2_T == 5'h3;
  wire        _resultBits_T_140 = _boardBlockIndex_3_T == 5'h3;
  wire        _resultBits_T_148 = shapeXCoord[4:1] == 4'h2;
  wire        _resultBits_T_156 = _boardBlockIndex_1_T == 5'h4;
  wire        _resultBits_T_164 = _boardBlockIndex_2_T == 5'h4;
  wire        _resultBits_T_172 = _boardBlockIndex_3_T == 5'h4;
  wire        _resultBits_T_188 = _boardBlockIndex_1_T == 5'h5;
  wire        _resultBits_T_196 = _boardBlockIndex_2_T == 5'h5;
  wire        _resultBits_T_204 = _boardBlockIndex_3_T == 5'h5;
  wire        _resultBits_T_212 = shapeXCoord[4:1] == 4'h3;
  wire        _resultBits_T_220 = _boardBlockIndex_1_T == 5'h6;
  wire        _resultBits_T_228 = _boardBlockIndex_2_T == 5'h6;
  wire        _resultBits_T_236 = _boardBlockIndex_3_T == 5'h6;
  wire        _resultBits_T_252 = _boardBlockIndex_1_T == 5'h7;
  wire        _resultBits_T_260 = _boardBlockIndex_2_T == 5'h7;
  wire        _resultBits_T_268 = _boardBlockIndex_3_T == 5'h7;
  wire        _resultBits_T_276 = shapeXCoord[4:1] == 4'h4;
  wire        _resultBits_T_284 = _boardBlockIndex_1_T == 5'h8;
  wire        _resultBits_T_292 = _boardBlockIndex_2_T == 5'h8;
  wire        _resultBits_T_300 = _boardBlockIndex_3_T == 5'h8;
  wire        _resultBits_T_316 = _boardBlockIndex_1_T == 5'h9;
  wire        _resultBits_T_324 = _boardBlockIndex_2_T == 5'h9;
  wire        _resultBits_T_332 = _boardBlockIndex_3_T == 5'h9;
  wire        _resultBits_T_340 = shapeXCoord[4:1] == 4'h5;
  wire        _resultBits_T_348 = _boardBlockIndex_1_T == 5'hA;
  wire        _resultBits_T_356 = _boardBlockIndex_2_T == 5'hA;
  wire        _resultBits_T_364 = _boardBlockIndex_3_T == 5'hA;
  wire        _resultBits_T_380 = _boardBlockIndex_1_T == 5'hB;
  wire        _resultBits_T_388 = _boardBlockIndex_2_T == 5'hB;
  wire        _resultBits_T_396 = _boardBlockIndex_3_T == 5'hB;
  wire        _resultBits_T_404 = shapeXCoord[4:1] == 4'h6;
  wire        _resultBits_T_412 = _boardBlockIndex_1_T == 5'hC;
  wire        _resultBits_T_420 = _boardBlockIndex_2_T == 5'hC;
  wire        _resultBits_T_428 = _boardBlockIndex_3_T == 5'hC;
  wire        _resultBits_T_444 = _boardBlockIndex_1_T == 5'hD;
  wire        _resultBits_T_452 = _boardBlockIndex_2_T == 5'hD;
  wire        _resultBits_T_460 = _boardBlockIndex_3_T == 5'hD;
  wire        _resultBits_T_468 = shapeXCoord[4:1] == 4'h7;
  wire        _resultBits_T_476 = _boardBlockIndex_1_T == 5'hE;
  wire        _resultBits_T_484 = _boardBlockIndex_2_T == 5'hE;
  wire        _resultBits_T_492 = _boardBlockIndex_3_T == 5'hE;
  wire        _resultBits_T_508 = _boardBlockIndex_1_T == 5'hF;
  wire        _resultBits_T_516 = _boardBlockIndex_2_T == 5'hF;
  wire        _resultBits_T_524 = _boardBlockIndex_3_T == 5'hF;
  wire        _resultBits_T_532 = shapeXCoord[4:1] == 4'h8;
  wire        _resultBits_T_540 = _boardBlockIndex_1_T == 5'h10;
  wire        _resultBits_T_548 = _boardBlockIndex_2_T == 5'h10;
  wire        _resultBits_T_556 = _boardBlockIndex_3_T == 5'h10;
  wire        _resultBits_T_572 = _boardBlockIndex_1_T == 5'h11;
  wire        _resultBits_T_580 = _boardBlockIndex_2_T == 5'h11;
  wire        _resultBits_T_588 = _boardBlockIndex_3_T == 5'h11;
  wire        _resultBits_T_596 = shapeXCoord[4:1] == 4'h9;
  wire        _resultBits_T_604 = _boardBlockIndex_1_T == 5'h12;
  wire        _resultBits_T_612 = _boardBlockIndex_2_T == 5'h12;
  wire        _resultBits_T_620 = _boardBlockIndex_3_T == 5'h12;
  wire [19:0] _boardRowDataD_T_1 =
    {io_shapeRowData[3] & _resultBits_T_620
       ? newBits[1]
       : io_shapeRowData[3] & _boardBlockIndex_3_T == 5'h13
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_612
               ? newBits[1]
               : io_shapeRowData[2] & _boardBlockIndex_2_T == 5'h13
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_604
                       ? newBits[1]
                       : io_shapeRowData[1] & _boardBlockIndex_1_T == 5'h13
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_596
                               ? newBits[1]
                               : io_boardRowDataIn[19],
     io_shapeRowData[3] & _resultBits_T_588
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_620
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_580
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_612
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_572
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_604 | io_shapeRowData[0]
                         & _resultBits_T_596
                           ? newBits[0]
                           : io_boardRowDataIn[18],
     io_shapeRowData[3] & _resultBits_T_556
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_588
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_548
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_580
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_540
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_572
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_532
                               ? newBits[1]
                               : io_boardRowDataIn[17],
     io_shapeRowData[3] & _resultBits_T_524
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_556
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_516
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_548
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_508
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_540 | io_shapeRowData[0]
                         & _resultBits_T_532
                           ? newBits[0]
                           : io_boardRowDataIn[16],
     io_shapeRowData[3] & _resultBits_T_492
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_524
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_484
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_516
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_476
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_508
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_468
                               ? newBits[1]
                               : io_boardRowDataIn[15],
     io_shapeRowData[3] & _resultBits_T_460
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_492
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_452
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_484
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_444
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_476 | io_shapeRowData[0]
                         & _resultBits_T_468
                           ? newBits[0]
                           : io_boardRowDataIn[14],
     io_shapeRowData[3] & _resultBits_T_428
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_460
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_420
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_452
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_412
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_444
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_404
                               ? newBits[1]
                               : io_boardRowDataIn[13],
     io_shapeRowData[3] & _resultBits_T_396
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_428
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_388
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_420
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_380
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_412 | io_shapeRowData[0]
                         & _resultBits_T_404
                           ? newBits[0]
                           : io_boardRowDataIn[12],
     io_shapeRowData[3] & _resultBits_T_364
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_396
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_356
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_388
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_348
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_380
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_340
                               ? newBits[1]
                               : io_boardRowDataIn[11],
     io_shapeRowData[3] & _resultBits_T_332
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_364
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_324
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_356
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_316
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_348 | io_shapeRowData[0]
                         & _resultBits_T_340
                           ? newBits[0]
                           : io_boardRowDataIn[10],
     io_shapeRowData[3] & _resultBits_T_300
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_332
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_292
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_324
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_284
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_316
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_276
                               ? newBits[1]
                               : io_boardRowDataIn[9],
     io_shapeRowData[3] & _resultBits_T_268
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_300
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_260
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_292
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_252
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_284 | io_shapeRowData[0]
                         & _resultBits_T_276
                           ? newBits[0]
                           : io_boardRowDataIn[8],
     io_shapeRowData[3] & _resultBits_T_236
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_268
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_228
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_260
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_220
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_252
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_212
                               ? newBits[1]
                               : io_boardRowDataIn[7],
     io_shapeRowData[3] & _resultBits_T_204
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_236
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_196
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_228
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_188
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_220 | io_shapeRowData[0]
                         & _resultBits_T_212
                           ? newBits[0]
                           : io_boardRowDataIn[6],
     io_shapeRowData[3] & _resultBits_T_172
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_204
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_164
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_196
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_156
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_188
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_148
                               ? newBits[1]
                               : io_boardRowDataIn[5],
     io_shapeRowData[3] & _resultBits_T_140
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_172
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_132
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_164
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_124
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_156 | io_shapeRowData[0]
                         & _resultBits_T_148
                           ? newBits[0]
                           : io_boardRowDataIn[4],
     io_shapeRowData[3] & _resultBits_T_108
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_140
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_100
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_132
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_92
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_124
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_84
                               ? newBits[1]
                               : io_boardRowDataIn[3],
     io_shapeRowData[3] & _resultBits_T_76
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_108
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_68
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_100
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_60
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_92 | io_shapeRowData[0]
                         & _resultBits_T_84
                           ? newBits[0]
                           : io_boardRowDataIn[2],
     io_shapeRowData[3] & _resultBits_T_44
       ? newBits[1]
       : io_shapeRowData[3] & _resultBits_T_76
           ? newBits[0]
           : io_shapeRowData[2] & _resultBits_T_36
               ? newBits[1]
               : io_shapeRowData[2] & _resultBits_T_68
                   ? newBits[0]
                   : io_shapeRowData[1] & _resultBits_T_28
                       ? newBits[1]
                       : io_shapeRowData[1] & _resultBits_T_60
                           ? newBits[0]
                           : io_shapeRowData[0] & _resultBits_T_20
                               ? newBits[1]
                               : io_boardRowDataIn[1],
     io_shapeRowData[3] & _resultBits_T_44 | io_shapeRowData[2] & _resultBits_T_36
     | io_shapeRowData[1] & _resultBits_T_28 | io_shapeRowData[0] & _resultBits_T_20
       ? newBits[0]
       : io_boardRowDataIn[0]};
  wire        doneD = (|stateQ) & ~inReadingState & inWritingState & (&rowIndexQ);
  always @(posedge clock) begin
    if (reset) begin
      stateQ <= 2'h0;
      boardRowDataQ <= 20'h0;
      rowIndexQ <= 2'h0;
      doneQ <= 1'h0;
      clearingQ <= 1'h0;
    end
    else begin
      if (|stateQ) begin
        if (inReadingState)
          stateQ <= 2'h2;
        else if (inWritingState)
          stateQ <= {1'h0, ~doneD};
        else if (io_start)
          stateQ <= 2'h1;
      end
      else if (io_start)
        stateQ <= 2'h1;
      if ((|stateQ) & inReadingState)
        boardRowDataQ <= _boardRowDataD_T_1;
      if (~(|stateQ) | inReadingState | ~inWritingState | doneD) begin
        if (io_start)
          rowIndexQ <= 2'h0;
      end
      else
        rowIndexQ <= rowIndexQ + 2'h1;
      doneQ <= doneD;
      clearingQ <= io_start ? io_clearShape : ~doneQ & clearingQ;
    end
  end // always @(posedge)
  assign io_reading = inReadingState;
  assign io_writing = inWritingState;
  assign io_boardRowDataOut = boardRowDataQ;
  assign io_rowIndex = rowIndexQ;
  assign io_done = doneQ;
endmodule

module TetrisCheckMoveAllowed(
  input         clock,
                reset,
                io_startCheck,
  input  [3:0]  io_shapeRowData,
  input  [19:0] io_boardRowData,
  input  [3:0]  io_shapeXCoord,
  input         io_rowIndexIsOutOfRange,
  output [1:0]  io_rowIndex,
  output        io_moveAllowed,
                io_checkDone
);

  reg  [1:0] rowIndexQ;
  reg        checkIsRunningQ;
  reg        doneQ;
  wire [4:0] _shapeXCoordOutsideRange_T = {1'h0, io_shapeXCoord} + 5'h4;
  wire [3:0] shapeXCoord = _shapeXCoordOutsideRange_T > 5'hE ? 4'h0 : io_shapeXCoord;
  wire       runningOrAssertingDone = checkIsRunningQ | doneQ;
  wire       _windowBits_candidates_T_78 = shapeXCoord == 4'h0;
  wire       _windowBits_candidates_T_80 = shapeXCoord == 4'h1;
  wire       _windowBits_candidates_T_82 = shapeXCoord == 4'h2;
  wire       _windowBits_candidates_T_84 = shapeXCoord == 4'h3;
  wire       _windowBits_candidates_T_86 = shapeXCoord == 4'h4;
  wire       _windowBits_candidates_T_88 = shapeXCoord == 4'h5;
  wire       _windowBits_candidates_T_90 = shapeXCoord == 4'h6;
  wire       _windowBits_candidates_T_92 = shapeXCoord == 4'h7;
  wire       _windowBits_candidates_T_94 = shapeXCoord == 4'h8;
  wire       _windowBits_candidates_T_96 = shapeXCoord == 4'h9;
  wire       _windowBits_candidates_T_98 = shapeXCoord == 4'hA;
  wire       _windowBits_candidates_T_76 = shapeXCoord == 4'hB;
  wire       _windowBits_candidates_T_52 = shapeXCoord == 4'hC;
  wire       io_moveAllowed_0 =
    runningOrAssertingDone & _shapeXCoordOutsideRange_T < 5'hF
    & ((runningOrAssertingDone & ~io_rowIndexIsOutOfRange
          ? {_windowBits_candidates_T_78 & (|(io_boardRowData[7:6]))
               | _windowBits_candidates_T_80 & (|(io_boardRowData[9:8]))
               | _windowBits_candidates_T_82 & (|(io_boardRowData[11:10]))
               | _windowBits_candidates_T_84 & (|(io_boardRowData[13:12]))
               | _windowBits_candidates_T_86 & (|(io_boardRowData[15:14]))
               | _windowBits_candidates_T_88 & (|(io_boardRowData[17:16]))
               | _windowBits_candidates_T_90 & (|(io_boardRowData[19:18]))
               | _windowBits_candidates_T_92 | _windowBits_candidates_T_94
               | _windowBits_candidates_T_96 | _windowBits_candidates_T_98,
             _windowBits_candidates_T_78 & (|(io_boardRowData[5:4]))
               | _windowBits_candidates_T_80 & (|(io_boardRowData[7:6]))
               | _windowBits_candidates_T_82 & (|(io_boardRowData[9:8]))
               | _windowBits_candidates_T_84 & (|(io_boardRowData[11:10]))
               | _windowBits_candidates_T_86 & (|(io_boardRowData[13:12]))
               | _windowBits_candidates_T_88 & (|(io_boardRowData[15:14]))
               | _windowBits_candidates_T_90 & (|(io_boardRowData[17:16]))
               | _windowBits_candidates_T_92 & (|(io_boardRowData[19:18]))
               | _windowBits_candidates_T_94 | _windowBits_candidates_T_96
               | _windowBits_candidates_T_98 | _windowBits_candidates_T_76,
             _windowBits_candidates_T_78 & (|(io_boardRowData[3:2]))
               | _windowBits_candidates_T_80 & (|(io_boardRowData[5:4]))
               | _windowBits_candidates_T_82 & (|(io_boardRowData[7:6]))
               | _windowBits_candidates_T_84 & (|(io_boardRowData[9:8]))
               | _windowBits_candidates_T_86 & (|(io_boardRowData[11:10]))
               | _windowBits_candidates_T_88 & (|(io_boardRowData[13:12]))
               | _windowBits_candidates_T_90 & (|(io_boardRowData[15:14]))
               | _windowBits_candidates_T_92 & (|(io_boardRowData[17:16]))
               | _windowBits_candidates_T_94 & (|(io_boardRowData[19:18]))
               | _windowBits_candidates_T_96 | _windowBits_candidates_T_98
               | _windowBits_candidates_T_76 | _windowBits_candidates_T_52,
             _windowBits_candidates_T_78 & (|(io_boardRowData[1:0]))
               | _windowBits_candidates_T_80 & (|(io_boardRowData[3:2]))
               | _windowBits_candidates_T_82 & (|(io_boardRowData[5:4]))
               | _windowBits_candidates_T_84 & (|(io_boardRowData[7:6]))
               | _windowBits_candidates_T_86 & (|(io_boardRowData[9:8]))
               | _windowBits_candidates_T_88 & (|(io_boardRowData[11:10]))
               | _windowBits_candidates_T_90 & (|(io_boardRowData[13:12]))
               | _windowBits_candidates_T_92 & (|(io_boardRowData[15:14]))
               | _windowBits_candidates_T_94 & (|(io_boardRowData[17:16]))
               | _windowBits_candidates_T_96 & (|(io_boardRowData[19:18]))
               | _windowBits_candidates_T_98 | _windowBits_candidates_T_76
               | _windowBits_candidates_T_52 | shapeXCoord == 4'hD}
          : 4'hF) & io_shapeRowData) == 4'h0;
  wire       doneD = checkIsRunningQ & ((&rowIndexQ) | ~io_moveAllowed_0);
  always @(posedge clock) begin
    if (reset) begin
      rowIndexQ <= 2'h0;
      checkIsRunningQ <= 1'h0;
      doneQ <= 1'h0;
    end
    else begin
      if (~checkIsRunningQ | doneD) begin
        if (checkIsRunningQ) begin
        end
        else
          rowIndexQ <= 2'h0;
      end
      else
        rowIndexQ <= rowIndexQ + 2'h1;
      checkIsRunningQ <= io_startCheck | ~doneD & checkIsRunningQ;
      doneQ <= doneD;
    end
  end // always @(posedge)
  assign io_rowIndex = rowIndexQ;
  assign io_moveAllowed = io_moveAllowed_0;
  assign io_checkDone = doneQ;
endmodule

module TetrisShiftTheBoard(
  input         clock,
                reset,
                io_start,
  input  [19:0] io_boardRowDataIn,
  output        io_reading,
                io_writing,
  output [19:0] io_boardRowDataOut,
  output [4:0]  io_rowIndex,
  output        io_incrementScore,
                io_done
);

  reg  [2:0]  stateQ;
  reg  [19:0] boardRowDataQ;
  reg  [4:0]  rowIndexQ;
  reg  [4:0]  linesToShiftQ;
  reg  [4:0]  shiftStartPosQ;
  reg         operationIsRunningQ;
  reg         internalStartTriggerQ;
  wire        inCountingRowsToShiftState = stateQ == 3'h1;
  wire        inShiftingRowsReadingState = stateQ == 3'h2;
  wire        inShiftingRowsWritingState = stateQ == 3'h3;
  wire        inClearingRowsState = stateQ == 3'h4;
  wire        inRepeatState = stateQ == 3'h5;
  wire        inDoneState = stateQ == 3'h6;
  wire        io_writing_0 = inShiftingRowsWritingState | inClearingRowsState;
  wire        startTriggered = io_start | internalStartTriggerQ;
  wire [9:0]  compressedBoardRow =
    {|(io_boardRowDataIn[19:18]),
     |(io_boardRowDataIn[17:16]),
     |(io_boardRowDataIn[15:14]),
     |(io_boardRowDataIn[13:12]),
     |(io_boardRowDataIn[11:10]),
     |(io_boardRowDataIn[9:8]),
     |(io_boardRowDataIn[7:6]),
     |(io_boardRowDataIn[5:4]),
     |(io_boardRowDataIn[3:2]),
     |(io_boardRowDataIn[1:0])};
  wire [2:0]  _GEN = startTriggered ? 3'h1 : stateQ;
  wire        _GEN_0 = (&compressedBoardRow) | (&shiftStartPosQ);
  wire        _GEN_1 = rowIndexQ == 5'h0;
  wire [2:0]  _stateD_T = {&shiftStartPosQ, 2'h2};
  wire [2:0]  _GEN_2 = _GEN_1 ? 3'h4 : 3'h2;
  wire        _GEN_3 = linesToShiftQ == 5'h0;
  wire        _GEN_4 = inClearingRowsState & _GEN_3;
  wire        _GEN_5 = inDoneState | inRepeatState;
  wire        _GEN_6 = ~inShiftingRowsWritingState | _GEN_1;
  always @(posedge clock) begin
    if (reset) begin
      stateQ <= 3'h0;
      boardRowDataQ <= 20'h0;
      rowIndexQ <= 5'h0;
      linesToShiftQ <= 5'h0;
      shiftStartPosQ <= 5'h0;
      operationIsRunningQ <= 1'h0;
      internalStartTriggerQ <= 1'h0;
    end
    else begin
      if (operationIsRunningQ) begin
        if (_GEN_5)
          stateQ <= 3'h0;
        else if (_GEN_4)
          stateQ <= 3'h5;
        else if (inShiftingRowsWritingState)
          stateQ <= _GEN_2;
        else if (inShiftingRowsReadingState)
          stateQ <= 3'h3;
        else if (inCountingRowsToShiftState) begin
          if (_GEN_1)
            stateQ <= _stateD_T;
          else if (_GEN_0) begin
            if (startTriggered)
              stateQ <= 3'h1;
          end
          else
            stateQ <= 3'h2;
        end
        else if (startTriggered)
          stateQ <= 3'h1;
        if (_GEN_6) begin
          if (~inCountingRowsToShiftState | _GEN_1
              | (operationIsRunningQ
                   ? (_GEN_5
                        ? 3'h0
                        : _GEN_4
                            ? 3'h5
                            : inShiftingRowsWritingState
                                ? _GEN_2
                                : inShiftingRowsReadingState
                                    ? 3'h3
                                    : inCountingRowsToShiftState
                                        ? (_GEN_1 ? _stateD_T : _GEN_0 ? _GEN : 3'h2)
                                        : _GEN)
                   : _GEN) == 3'h2) begin
            if (startTriggered)
              rowIndexQ <= 5'h13;
          end
          else
            rowIndexQ <= rowIndexQ - 5'h1;
        end
        else
          rowIndexQ <= rowIndexQ - 5'h1;
        if (~inClearingRowsState | _GEN_3) begin
          if (inShiftingRowsWritingState & _GEN_1)
            linesToShiftQ <= linesToShiftQ - 5'h1;
          else if (inCountingRowsToShiftState) begin
            if (_GEN_1)
              linesToShiftQ <= shiftStartPosQ - rowIndexQ;
            else if (_GEN_0) begin
            end
            else
              linesToShiftQ <= shiftStartPosQ - rowIndexQ;
          end
        end
        else
          linesToShiftQ <= linesToShiftQ - 5'h1;
        if (_GEN_6) begin
          if (inCountingRowsToShiftState & (&compressedBoardRow) & (&shiftStartPosQ))
            shiftStartPosQ <= rowIndexQ;
          else if (startTriggered)
            shiftStartPosQ <= 5'h1F;
        end
        else
          shiftStartPosQ <= shiftStartPosQ - 5'h1;
      end
      else if (startTriggered) begin
        stateQ <= 3'h1;
        rowIndexQ <= 5'h13;
        shiftStartPosQ <= 5'h1F;
      end
      if (operationIsRunningQ & inShiftingRowsReadingState)
        boardRowDataQ <= io_boardRowDataIn;
      operationIsRunningQ <= io_start | ~inDoneState & operationIsRunningQ;
      internalStartTriggerQ <=
        operationIsRunningQ & inRepeatState | ~startTriggered & internalStartTriggerQ;
    end
  end // always @(posedge)
  assign io_reading = inCountingRowsToShiftState | inShiftingRowsReadingState;
  assign io_writing = io_writing_0;
  assign io_boardRowDataOut = inClearingRowsState ? 20'h0 : boardRowDataQ;
  assign io_rowIndex =
    inClearingRowsState ? linesToShiftQ : io_writing_0 ? shiftStartPosQ : rowIndexQ;
  assign io_incrementScore =
    operationIsRunningQ & inCountingRowsToShiftState & (&compressedBoardRow);
  assign io_done = inDoneState;
endmodule

module TetrisGameOverLogic(
  input  clock,
         reset,
         io_enterGameOverState,
         io_downButtonActive,
  output io_inGameOverState,
         io_gameOverReset
);

  reg        inGameOverStateQ;
  reg  [1:0] buttonPressesCounterQ;
  wire       inGameOverStateD =
    io_enterGameOverState | ~(inGameOverStateQ & buttonPressesCounterQ == 2'h1)
    & inGameOverStateQ;
  always @(posedge clock) begin
    if (reset) begin
      inGameOverStateQ <= 1'h0;
      buttonPressesCounterQ <= 2'h0;
    end
    else begin
      inGameOverStateQ <= inGameOverStateD;
      if (io_enterGameOverState)
        buttonPressesCounterQ <= 2'h0;
      else if (inGameOverStateQ)
        buttonPressesCounterQ <= buttonPressesCounterQ + {1'h0, io_downButtonActive};
    end
  end // always @(posedge)
  assign io_inGameOverState = inGameOverStateQ;
  assign io_gameOverReset = inGameOverStateQ & ~inGameOverStateD;
endmodule

module BCDAdder(
  input  [3:0] io_a,
  input        io_cin,
  output [3:0] io_sum,
  output       io_cout
);

  wire [5:0] binarySum = {2'h0, io_a} + {5'h0, io_cin};
  wire       io_cout_0 = {1'h0, binarySum} > 7'h9;
  assign io_sum = io_cout_0 ? binarySum[3:0] + 4'h6 : binarySum[3:0];
  assign io_cout = io_cout_0;
endmodule

module TetrisScoreCounter(
  input        clock,
               reset,
               io_incrementScore,
               io_resetToZero,
  output [3:0] io_score_0,
               io_score_1,
               io_score_2,
               io_score_3
);

  wire [3:0] _bcdAdder_3_io_sum;
  wire [3:0] _bcdAdder_2_io_sum;
  wire       _bcdAdder_2_io_cout;
  wire [3:0] _bcdAdder_1_io_sum;
  wire       _bcdAdder_1_io_cout;
  wire [3:0] _bcdAdder_io_sum;
  wire       _bcdAdder_io_cout;
  reg  [3:0] scoreQ_0;
  reg  [3:0] scoreQ_1;
  reg  [3:0] scoreQ_2;
  reg  [3:0] scoreQ_3;
  always @(posedge clock) begin
    if (reset) begin
      scoreQ_0 <= 4'h0;
      scoreQ_1 <= 4'h0;
      scoreQ_2 <= 4'h0;
      scoreQ_3 <= 4'h0;
    end
    else begin
      scoreQ_0 <= io_resetToZero ? 4'h0 : _bcdAdder_io_sum;
      scoreQ_1 <= io_resetToZero ? 4'h0 : _bcdAdder_1_io_sum;
      scoreQ_2 <= io_resetToZero ? 4'h0 : _bcdAdder_2_io_sum;
      scoreQ_3 <= io_resetToZero ? 4'h0 : _bcdAdder_3_io_sum;
    end
  end // always @(posedge)
  BCDAdder bcdAdder (
    .io_a    (scoreQ_0),
    .io_cin  (io_incrementScore & scoreQ_3 != 4'h9),
    .io_sum  (_bcdAdder_io_sum),
    .io_cout (_bcdAdder_io_cout)
  );
  BCDAdder bcdAdder_1 (
    .io_a    (scoreQ_1),
    .io_cin  (_bcdAdder_io_cout),
    .io_sum  (_bcdAdder_1_io_sum),
    .io_cout (_bcdAdder_1_io_cout)
  );
  BCDAdder bcdAdder_2 (
    .io_a    (scoreQ_2),
    .io_cin  (_bcdAdder_1_io_cout),
    .io_sum  (_bcdAdder_2_io_sum),
    .io_cout (_bcdAdder_2_io_cout)
  );
  BCDAdder bcdAdder_3 (
    .io_a    (scoreQ_3),
    .io_cin  (_bcdAdder_2_io_cout),
    .io_sum  (_bcdAdder_3_io_sum),
    .io_cout (/* unused */)
  );
  assign io_score_0 = scoreQ_0;
  assign io_score_1 = scoreQ_1;
  assign io_score_2 = scoreQ_2;
  assign io_score_3 = scoreQ_3;
endmodule

module TetrisLogic(
  input         clock,
                reset,
                io_start,
                io_rotateButtonActive,
                io_leftButtonActive,
                io_rightButtonActive,
                io_downButtonActive,
  input  [19:0] io_boardRowDataIn,
  output        io_reading,
                io_writing,
  output [19:0] io_boardRowDataOut,
  output [4:0]  io_rowIndex,
  output [3:0]  io_score_0,
                io_score_1,
                io_score_2,
                io_score_3,
  output        io_gameOver,
                io_done
);

  wire        _gameOverLogic_io_inGameOverState;
  wire        _gameOverLogic_io_gameOverReset;
  wire        _shiftTheBoard_io_reading;
  wire        _shiftTheBoard_io_writing;
  wire [19:0] _shiftTheBoard_io_boardRowDataOut;
  wire [4:0]  _shiftTheBoard_io_rowIndex;
  wire        _shiftTheBoard_io_incrementScore;
  wire        _shiftTheBoard_io_done;
  wire [1:0]  _checkMoveAllowed_io_rowIndex;
  wire        _checkMoveAllowed_io_moveAllowed;
  wire        _checkMoveAllowed_io_checkDone;
  wire        _addOrRemoveShape_io_reading;
  wire        _addOrRemoveShape_io_writing;
  wire [19:0] _addOrRemoveShape_io_boardRowDataOut;
  wire [1:0]  _addOrRemoveShape_io_rowIndex;
  wire        _addOrRemoveShape_io_done;
  wire [3:0]  _shapeDataProvider_io_shapeRowData;
  wire [1:0]  _shapeDataProvider_io_currentShapeLastRotationId;
  wire [4:0]  _adderSubtracter_io_result;
  wire [2:0]  _tetrisLFSRPseudoRandomNumGen_io_random;
  reg  [3:0]  posXQ;
  reg  [4:0]  posYQ;
  reg  [2:0]  shapeTypeQ;
  reg  [1:0]  rotationQ;
  reg  [4:0]  stateQ;
  reg  [5:0]  shapeDropTimerQ;
  reg         gameOverResetHappenedQ;
  wire        inInitialClearBoardState = stateQ == 5'h1;
  wire        inInitState = stateQ == 5'h2;
  wire        inRemoveShapeFromTheBoardState = stateQ == 5'h4;
  wire        inGetInputState = stateQ == 5'h5;
  wire        inRotateIsAllowedState = stateQ == 5'h6;
  wire        inMoveLeftIfAllowedState = stateQ == 5'h7;
  wire        inMoveRightIfAllowedState = stateQ == 5'h8;
  wire        inMoveShapeDownStateStep0 = stateQ == 5'h9;
  wire        inMoveShapeDownStateStep1 = stateQ == 5'hA;
  wire        inCheckIfShapeStoppedMovingState = stateQ == 5'hB;
  wire        inAddShapeToTheBoardState = stateQ == 5'hC;
  wire        inAddShapeToTheBoardAndDoneState = stateQ == 5'hD;
  wire        inShiftBoardState = stateQ == 5'hE;
  wire        inGetNextShapeState = stateQ == 5'hF;
  wire        inCheckIfGameOverStep0State = stateQ == 5'h10;
  wire        inCheckIfGameOverStep1State = stateQ == 5'h11;
  wire        inDoneWithGameOverState = stateQ == 5'h13;
  wire        inDoneAfterInitialBoardClearState = stateQ == 5'h14;
  wire        inDoneState = stateQ == 5'h15;
  wire        addingOrRemovingShape =
    inRemoveShapeFromTheBoardState | inAddShapeToTheBoardState
    | inAddShapeToTheBoardAndDoneState;
  wire        inMoveIfAllowedState =
    inRotateIsAllowedState | inMoveLeftIfAllowedState | inMoveRightIfAllowedState
    | inMoveShapeDownStateStep0 | inMoveShapeDownStateStep1
    | inCheckIfShapeStoppedMovingState | inCheckIfGameOverStep0State
    | inCheckIfGameOverStep1State;
  wire        io_done_0 =
    inDoneState | inDoneWithGameOverState | inDoneAfterInitialBoardClearState;
  wire [1:0]  relativeRowIndex =
    addingOrRemovingShape
      ? _addOrRemoveShape_io_rowIndex
      : inMoveIfAllowedState ? _checkMoveAllowed_io_rowIndex : 2'h0;
  wire [4:0]  rowIndex =
    inShiftBoardState
      ? _shiftTheBoard_io_rowIndex
      : addingOrRemovingShape | inMoveIfAllowedState
          ? posYQ + {3'h0, relativeRowIndex}
          : posYQ;
  wire        shapeYCoordOutsideTheRange = rowIndex > 5'h13;
  reg  [1:0]  casez_tmp;
  always_comb begin
    casez (shapeTypeQ)
      3'b000:
        casez_tmp = 2'h1;
      3'b001:
        casez_tmp = 2'h2;
      3'b010:
        casez_tmp = 2'h3;
      3'b011:
        casez_tmp = 2'h1;
      3'b100:
        casez_tmp = 2'h2;
      3'b101:
        casez_tmp = 2'h3;
      3'b110:
        casez_tmp = 2'h1;
      default:
        casez_tmp = 2'h1;
    endcase
  end // always_comb
  wire        clearingBoard = stateQ == 5'h12 | inInitialClearBoardState;
  wire        shapeDropTimerSaturated =
    shapeDropTimerQ >= (io_downButtonActive ? 6'h5 : 6'h3C);
  wire        _genRandomNum_T = stateQ == 5'h3 | inInitState;
  wire        _GEN = io_leftButtonActive & (|posXQ);
  wire        _GEN_0 = io_rightButtonActive & posXQ != 4'h9;
  wire        _GEN_1 = inGetInputState & (io_rotateButtonActive | _GEN | _GEN_0);
  wire        _GEN_2 = inMoveShapeDownStateStep0 & shapeDropTimerSaturated;
  wire        _GEN_3 = inCheckIfShapeStoppedMovingState & _checkMoveAllowed_io_checkDone;
  wire        _GEN_4 =
    (inAddShapeToTheBoardState | inAddShapeToTheBoardAndDoneState)
    & _addOrRemoveShape_io_done;
  wire        _GEN_5 = inCheckIfGameOverStep0State & _checkMoveAllowed_io_checkDone;
  wire        shapeYCoordLastIndex = rowIndex == 5'h13;
  wire        _GEN_6 = _genRandomNum_T & io_start;
  wire        _GEN_7 =
    ~_GEN_6 | _gameOverLogic_io_inGameOverState | gameOverResetHappenedQ | ~inInitState;
  wire        _GEN_8 = _checkMoveAllowed_io_checkDone & ~_checkMoveAllowed_io_moveAllowed;
  wire        _GEN_9 = inMoveShapeDownStateStep1 & _checkMoveAllowed_io_checkDone;
  wire        _GEN_10 = inCheckIfGameOverStep1State & _GEN_8;
  wire        _GEN_11 = inCheckIfGameOverStep1State & _checkMoveAllowed_io_checkDone;
  always @(posedge clock) begin
    if (reset) begin
      posXQ <= 4'h0;
      posYQ <= 5'h0;
      shapeTypeQ <= 3'h0;
      rotationQ <= 2'h0;
      stateQ <= 5'h0;
      shapeDropTimerQ <= 6'h0;
      gameOverResetHappenedQ <= 1'h0;
    end
    else begin
      if (_GEN_10 | _GEN_5 & ~_checkMoveAllowed_io_moveAllowed | inGetNextShapeState)
        posXQ <= 4'h3;
      else if (inMoveRightIfAllowedState & _GEN_8)
        posXQ <= posXQ - 4'h1;
      else if (inMoveLeftIfAllowedState & _GEN_8)
        posXQ <= posXQ + 4'h1;
      else if (~inGetInputState | io_rotateButtonActive) begin
        if (_GEN_7) begin
        end
        else
          posXQ <= 4'h3;
      end
      else if (_GEN)
        posXQ <= posXQ - 4'h1;
      else if (_GEN_0)
        posXQ <= posXQ + 4'h1;
      else if (_GEN_7) begin
      end
      else
        posXQ <= 4'h3;
      if (clearingBoard)
        posYQ <= shapeYCoordLastIndex ? 5'h0 : _adderSubtracter_io_result;
      else if (_GEN_11 | _GEN_5)
        posYQ <= _checkMoveAllowed_io_moveAllowed ? _adderSubtracter_io_result : 5'h0;
      else if (inGetNextShapeState)
        posYQ <= 5'h0;
      else if (_GEN_3 | _GEN_9 & _checkMoveAllowed_io_moveAllowed | _GEN_2)
        posYQ <= _adderSubtracter_io_result;
      else if (~_GEN_6 | _gameOverLogic_io_inGameOverState
               | ~(gameOverResetHappenedQ | inInitState)) begin
      end
      else
        posYQ <= 5'h0;
      if (_GEN_10 | inCheckIfGameOverStep0State & _GEN_8)
        shapeTypeQ <= 3'h0;
      else if (inGetNextShapeState)
        shapeTypeQ <= _tetrisLFSRPseudoRandomNumGen_io_random;
      else if (_GEN_7) begin
      end
      else
        shapeTypeQ <= 3'h0;
      if (inGetNextShapeState)
        rotationQ <= 2'h0;
      else if (inRotateIsAllowedState & _GEN_8)
        rotationQ <=
          rotationQ == 2'h0
            ? _shapeDataProvider_io_currentShapeLastRotationId
            : rotationQ - 2'h1;
      else if (inGetInputState & io_rotateButtonActive)
        rotationQ <=
          rotationQ < _shapeDataProvider_io_currentShapeLastRotationId
            ? rotationQ + 2'h1
            : 2'h0;
      if (inDoneState)
        stateQ <= 5'h3;
      else if (inDoneAfterInitialBoardClearState)
        stateQ <= 5'h2;
      else if (inDoneWithGameOverState)
        stateQ <= 5'h3;
      else if (clearingBoard & shapeYCoordLastIndex)
        stateQ <= {4'hA, ~inInitialClearBoardState};
      else if (_GEN_11)
        stateQ <= _checkMoveAllowed_io_moveAllowed ? 5'h15 : 5'h13;
      else if (_GEN_5)
        stateQ <= {3'h4, ~_checkMoveAllowed_io_moveAllowed, 1'h1};
      else if (inGetNextShapeState)
        stateQ <= 5'h10;
      else if (inShiftBoardState & _shiftTheBoard_io_done)
        stateQ <= 5'hF;
      else if (_GEN_4)
        stateQ <= inAddShapeToTheBoardAndDoneState ? 5'h15 : 5'hE;
      else if (_GEN_3)
        stateQ <= {4'h6, _checkMoveAllowed_io_moveAllowed};
      else if (_GEN_9)
        stateQ <= 5'hB;
      else if (inMoveShapeDownStateStep0)
        stateQ <= shapeDropTimerSaturated ? 5'hA : 5'hD;
      else if (inMoveRightIfAllowedState & _checkMoveAllowed_io_checkDone
               | inMoveLeftIfAllowedState & _checkMoveAllowed_io_checkDone
               | inRotateIsAllowedState & _checkMoveAllowed_io_checkDone)
        stateQ <= 5'h9;
      else if (inGetInputState)
        stateQ <= io_rotateButtonActive ? 5'h6 : _GEN ? 5'h7 : {4'h4, ~_GEN_0};
      else if (inRemoveShapeFromTheBoardState & _addOrRemoveShape_io_done)
        stateQ <= 5'h5;
      else if (_GEN_6)
        stateQ <=
          _gameOverLogic_io_inGameOverState
            ? 5'h15
            : gameOverResetHappenedQ ? 5'h12 : 5'h4;
      else if (stateQ == 5'h0 & io_start)
        stateQ <= 5'h1;
      shapeDropTimerQ <=
        shapeDropTimerSaturated & io_done_0 ? 6'h0 : shapeDropTimerQ + {5'h0, io_start};
      gameOverResetHappenedQ <=
        (~_GEN_6 | _gameOverLogic_io_inGameOverState | ~gameOverResetHappenedQ)
        & (gameOverResetHappenedQ
             ? gameOverResetHappenedQ
             : _gameOverLogic_io_gameOverReset);
    end
  end // always @(posedge)
  TetrisLFSRPseudoRandomNumGen tetrisLFSRPseudoRandomNumGen (
    .clock     (clock),
    .reset     (reset),
    .io_enable (~_genRandomNum_T),
    .io_random (_tetrisLFSRPseudoRandomNumGen_io_random)
  );
  AdderSubtracter adderSubtracter (
    .io_a        (posYQ),
    .io_subtract (inCheckIfShapeStoppedMovingState | inCheckIfGameOverStep1State),
    .io_result   (_adderSubtracter_io_result)
  );
  TetrisShapeDataProvider shapeDataProvider (
    .io_shapeSelector              (shapeTypeQ),
    .io_shapeRotationSelector      (rotationQ),
    .io_shapeDataRowIndex          (relativeRowIndex),
    .io_shapeRowData               (_shapeDataProvider_io_shapeRowData),
    .io_currentShapeLastRotationId (_shapeDataProvider_io_currentShapeLastRotationId)
  );
  TetrisAddCurrentShapeToOrRemoveFromTheBoard addOrRemoveShape (
    .clock              (clock),
    .reset              (reset),
    .io_start
      (_GEN_3 | inMoveShapeDownStateStep0 & ~shapeDropTimerSaturated | io_start),
    .io_clearShape      (io_start),
    .io_shapeRowData    (_shapeDataProvider_io_shapeRowData),
    .io_shapeColor      (casez_tmp),
    .io_boardRowDataIn  (io_boardRowDataIn),
    .io_shapeXCoord     (posXQ),
    .io_reading         (_addOrRemoveShape_io_reading),
    .io_writing         (_addOrRemoveShape_io_writing),
    .io_boardRowDataOut (_addOrRemoveShape_io_boardRowDataOut),
    .io_rowIndex        (_addOrRemoveShape_io_rowIndex),
    .io_done            (_addOrRemoveShape_io_done)
  );
  TetrisCheckMoveAllowed checkMoveAllowed (
    .clock                   (clock),
    .reset                   (reset),
    .io_startCheck
      (_GEN_5 & _checkMoveAllowed_io_moveAllowed | inGetNextShapeState
       | (inMoveShapeDownStateStep1
            ? _checkMoveAllowed_io_checkDone | _GEN_2 | _GEN_1
            : _GEN_2 | _GEN_1)),
    .io_shapeRowData         (_shapeDataProvider_io_shapeRowData),
    .io_boardRowData         (io_boardRowDataIn),
    .io_shapeXCoord          (posXQ),
    .io_rowIndexIsOutOfRange (shapeYCoordOutsideTheRange),
    .io_rowIndex             (_checkMoveAllowed_io_rowIndex),
    .io_moveAllowed          (_checkMoveAllowed_io_moveAllowed),
    .io_checkDone            (_checkMoveAllowed_io_checkDone)
  );
  TetrisShiftTheBoard shiftTheBoard (
    .clock              (clock),
    .reset              (reset),
    .io_start           (_GEN_4 & stateQ != 5'hD),
    .io_boardRowDataIn  (io_boardRowDataIn),
    .io_reading         (_shiftTheBoard_io_reading),
    .io_writing         (_shiftTheBoard_io_writing),
    .io_boardRowDataOut (_shiftTheBoard_io_boardRowDataOut),
    .io_rowIndex        (_shiftTheBoard_io_rowIndex),
    .io_incrementScore  (_shiftTheBoard_io_incrementScore),
    .io_done            (_shiftTheBoard_io_done)
  );
  TetrisGameOverLogic gameOverLogic (
    .clock                 (clock),
    .reset                 (reset),
    .io_enterGameOverState (inDoneWithGameOverState),
    .io_downButtonActive   (io_downButtonActive),
    .io_inGameOverState    (_gameOverLogic_io_inGameOverState),
    .io_gameOverReset      (_gameOverLogic_io_gameOverReset)
  );
  TetrisScoreCounter scoreCounter (
    .clock             (clock),
    .reset             (reset),
    .io_incrementScore (_shiftTheBoard_io_incrementScore),
    .io_resetToZero    (_gameOverLogic_io_gameOverReset),
    .io_score_0        (io_score_0),
    .io_score_1        (io_score_1),
    .io_score_2        (io_score_2),
    .io_score_3        (io_score_3)
  );
  assign io_reading =
    inMoveIfAllowedState
    | (addingOrRemovingShape ? _addOrRemoveShape_io_reading : _shiftTheBoard_io_reading);
  assign io_writing =
    clearingBoard | rowIndex < 5'h14
    & (addingOrRemovingShape ? _addOrRemoveShape_io_writing : _shiftTheBoard_io_writing);
  assign io_boardRowDataOut =
    clearingBoard
      ? 20'h0
      : addingOrRemovingShape
          ? _addOrRemoveShape_io_boardRowDataOut
          : _shiftTheBoard_io_boardRowDataOut;
  assign io_rowIndex = shapeYCoordOutsideTheRange ? posYQ : rowIndex;
  assign io_gameOver = _gameOverLogic_io_inGameOverState;
  assign io_done = io_done_0;
endmodule

module VGATetris(
  input        clock,
               reset,
               io_button1,
               io_button2,
               io_button3,
               io_button4,
  output [1:0] io_vgaR,
               io_vgaG,
               io_vgaB,
  output       io_vgaHs,
               io_vgaVs,
  output [9:0] io_pxX,
               io_pxY
);

  wire        _tetrisLogic_io_reading;
  wire        _tetrisLogic_io_writing;
  wire [19:0] _tetrisLogic_io_boardRowDataOut;
  wire [4:0]  _tetrisLogic_io_rowIndex;
  wire [3:0]  _tetrisLogic_io_score_0;
  wire [3:0]  _tetrisLogic_io_score_1;
  wire [3:0]  _tetrisLogic_io_score_2;
  wire [3:0]  _tetrisLogic_io_score_3;
  wire        _tetrisLogic_io_gameOver;
  wire        _tetrisLogic_io_done;
  wire        _inputs_io_rotateButtonActive;
  wire        _inputs_io_leftButtonActive;
  wire        _inputs_io_rightButtonActive;
  wire        _inputs_io_downButtonActive;
  wire        _msTimer_io_tick;
  wire [19:0] _boardMem_io_readRowData;
  wire        _tetrisDisplay_io_coordsValid;
  wire [4:0]  _tetrisDisplay_io_boardYCoord;
  wire        _vgaController_io_vSync;
  wire [9:0]  _vgaController_io_pixelPosX;
  wire [9:0]  _vgaController_io_pixelPosY;
  wire        _vgaController_io_pixelPosIsValid;
  reg         runningTetrisLogicQ;
  reg         startTetrisLogicQ;
  wire        startTetrisLogicD =
    ~runningTetrisLogicQ & ~startTetrisLogicQ & ~_vgaController_io_vSync
    & ~_vgaController_io_pixelPosIsValid;
  always @(posedge clock) begin
    if (reset) begin
      runningTetrisLogicQ <= 1'h0;
      startTetrisLogicQ <= 1'h0;
    end
    else begin
      if (runningTetrisLogicQ)
        runningTetrisLogicQ <= ~_vgaController_io_vSync;
      else
        runningTetrisLogicQ <= ~startTetrisLogicQ & startTetrisLogicD;
      startTetrisLogicQ <= startTetrisLogicD;
    end
  end // always @(posedge)
  VGAController vgaController (
    .clock              (clock),
    .reset              (reset),
    .io_hSync           (io_vgaHs),
    .io_vSync           (_vgaController_io_vSync),
    .io_pixelPosX       (_vgaController_io_pixelPosX),
    .io_pixelPosY       (_vgaController_io_pixelPosY),
    .io_pixelPosIsValid (_vgaController_io_pixelPosIsValid)
  );
  TetrisDisplay tetrisDisplay (
    .io_reset           (reset),
    .io_pixelPosIsValid (_vgaController_io_pixelPosIsValid),
    .io_pxX             (_vgaController_io_pixelPosX),
    .io_pxY             (_vgaController_io_pixelPosY),
    .io_showGameOver    (_tetrisLogic_io_gameOver),
    .io_score_0         (_tetrisLogic_io_score_0),
    .io_score_1         (_tetrisLogic_io_score_1),
    .io_score_2         (_tetrisLogic_io_score_2),
    .io_score_3         (_tetrisLogic_io_score_3),
    .io_boardRowData    (_boardMem_io_readRowData),
    .io_coordsValid     (_tetrisDisplay_io_coordsValid),
    .io_boardYCoord     (_tetrisDisplay_io_boardYCoord),
    .io_vgaR            (io_vgaR),
    .io_vgaG            (io_vgaG),
    .io_vgaB            (io_vgaB)
  );
  TetrisBoardMemory boardMem (
    .clock           (clock),
    .io_wen          (_tetrisLogic_io_writing),
    .io_ren
      (runningTetrisLogicQ ? _tetrisLogic_io_reading : _tetrisDisplay_io_coordsValid),
    .io_readYCoord
      (runningTetrisLogicQ ? _tetrisLogic_io_rowIndex : _tetrisDisplay_io_boardYCoord),
    .io_writeYCoord  (_tetrisLogic_io_rowIndex),
    .io_writeRowData (_tetrisLogic_io_boardRowDataOut),
    .io_readRowData  (_boardMem_io_readRowData)
  );
  MillisecondTimer msTimer (
    .clock   (clock),
    .reset   (reset),
    .io_tick (_msTimer_io_tick)
  );
  TetrisInputs inputs (
    .clock                   (clock),
    .reset                   (reset),
    .io_millisecondTimerTick (_msTimer_io_tick),
    .io_clear                (_tetrisLogic_io_done),
    .io_rotateButtonPressed  (io_button3),
    .io_leftButtonPressed    (io_button1),
    .io_rightButtonPressed   (io_button2),
    .io_downButtonPressed    (io_button4),
    .io_rotateButtonActive   (_inputs_io_rotateButtonActive),
    .io_leftButtonActive     (_inputs_io_leftButtonActive),
    .io_rightButtonActive    (_inputs_io_rightButtonActive),
    .io_downButtonActive     (_inputs_io_downButtonActive)
  );
  TetrisLogic tetrisLogic (
    .clock                 (clock),
    .reset                 (reset),
    .io_start              (startTetrisLogicQ),
    .io_rotateButtonActive (_inputs_io_rotateButtonActive),
    .io_leftButtonActive   (_inputs_io_leftButtonActive),
    .io_rightButtonActive  (_inputs_io_rightButtonActive),
    .io_downButtonActive   (_inputs_io_downButtonActive),
    .io_boardRowDataIn     (_boardMem_io_readRowData),
    .io_reading            (_tetrisLogic_io_reading),
    .io_writing            (_tetrisLogic_io_writing),
    .io_boardRowDataOut    (_tetrisLogic_io_boardRowDataOut),
    .io_rowIndex           (_tetrisLogic_io_rowIndex),
    .io_score_0            (_tetrisLogic_io_score_0),
    .io_score_1            (_tetrisLogic_io_score_1),
    .io_score_2            (_tetrisLogic_io_score_2),
    .io_score_3            (_tetrisLogic_io_score_3),
    .io_gameOver           (_tetrisLogic_io_gameOver),
    .io_done               (_tetrisLogic_io_done)
  );
  assign io_vgaVs = _vgaController_io_vSync;
  assign io_pxX = _vgaController_io_pixelPosX;
  assign io_pxY = _vgaController_io_pixelPosY;
endmodule

